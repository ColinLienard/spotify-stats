import Head from "next/head";
import { useRouter } from "next/router";
import { GetServerSideProps } from "next";
import { FC, useContext, useEffect, useRef, useState } from "react";
import NavBar from "../components/NavBar/NavBar";
import MusicController from "../components/MusicController/MusicController";
import TopSection from "../components/TopSection/TopSection";
import ArtistsSection from "../components/MusicSections/ArtistsSection";
import TracksSection from "../components/MusicSections/TracksSection";
import GenresSection from "../components/MusicSections/GenresSection";
import { MusicListContext } from "../lib/contexts/MusicListContext";
import { userData, ArtistList, TrackList, ArtistContent, TrackContent } from "../lib/types";

interface Props {
    user: userData,
    artists: ArtistList,
    tracks: TrackList
}

const Stats: FC<Props> = ({ user, artists, tracks }) => {
    const [accessToken, setAccessToken] = useState("");
    const { dispatchArtistList, dispatchTrackList } = useContext(MusicListContext);
    const [timeLimit, setTimeLimit] = useState("short_term");
    const firstUpdate = useRef(true);
    const router = useRouter();

    useEffect(() => {
        router.replace("/stats", undefined, { shallow: true });

        const cookie: string | undefined = document.cookie;
        if(cookie) {
            setAccessToken(cookie
                .split("; ")
                .find((row) => row.startsWith("accessToken="))!
                .split("=")[1]
            );
        }

        dispatchArtistList({ type: "reset", value: artists.items })
        dispatchTrackList({ type: "reset", value: tracks.items })
    }, [])

    useEffect(() => {
        if(firstUpdate.current) {
            firstUpdate.current = false;
            return;
        }

        const getNewArtists = async () => {
            const newArtistList = await getData(`https://api.spotify.com/v1/me/top/artists?time_range=${timeLimit}&limit=10`);
            dispatchArtistList({ type: "reset", value: newArtistList.items as ArtistContent[] });
        }

        const getNewTracks = async () => {
            const newTrackList = await getData(`https://api.spotify.com/v1/me/top/tracks?time_range=${timeLimit}&limit=10`);
            dispatchTrackList({ type: "reset", value: newTrackList.items as TrackContent[] });
        }

        getNewArtists();
        getNewTracks();
    }, [timeLimit])

    const getData = async (url: string): Promise<ArtistList | TrackList> => {
        try {
            const response = await fetch(url, {
                method: "GET",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${accessToken}`
                }
            });
            
            return await response.json();
        } catch(error) {
            console.error(error);
            return { items: [] }
        }
    }

    return (<>
        <Head>
            <title>Create Next App</title>
            <meta name="description" content="Generated by create next app" />
            <link rel="icon" href="/favicon.ico" />
        </Head>
        <NavBar logged={true} userData={user}/>
        <main role="main">
            <MusicController tracks={tracks.items}/>
            <TopSection name={user.display_name} timeLimit={timeLimit} setTimeLimit={setTimeLimit}/>
            <ArtistsSection timeLimit={timeLimit} getData={getData}/>
            <TracksSection timeLimit={timeLimit} getData={getData}/>
            <GenresSection/>
        </main>
    </>)
}

export const getServerSideProps: GetServerSideProps = async ctx => {

    const getData = async (url: string, accessToken: string) => {
        try {
            const response = await fetch(url, {
                method: "GET",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${accessToken}`
                }
            });
            if(response.ok)
                return await response.json();
        } catch(error) {
            console.error(error);
        }
    }

    const getAllData = async (accessToken: string) => {
        const user = await getData("https://api.spotify.com/v1/me", accessToken);
        const artists = await getData("https://api.spotify.com/v1/me/top/artists?time_range=short_term&limit=10", accessToken);
        const tracks = await getData("https://api.spotify.com/v1/me/top/tracks?time_range=short_term&limit=10", accessToken);

        return {
            props: {
                user,
                artists,
                tracks
            }
        }
    }

    if(ctx.query.code) {
        try {
            const response = await fetch(`${process.env.URL}/api/login?code=${ctx.query.code}&lang=${ctx.locale}`);
            if(response.ok) {
                const json = await response.json();
                
                const date = new Date();
                date.setTime(date.getTime() + json.expires_in * 1000);
                
                ctx.res.setHeader("Set-Cookie", [
                    `accessToken=${json.access_token}; path=/; expires=${date.toUTCString()};`,
                    `refreshToken=${json.refresh_token}; path=/;`
                ]);
                ctx.res.statusCode = 200;

                return getAllData(json.access_token);
            }
        } catch(error) {
            console.error(error);
        }
    } else if(ctx.req.cookies.accessToken)
        return getAllData(ctx.req.cookies.accessToken);
    
    else if(ctx.req.cookies.refreshToken) {
        console.log("refresh");
    }

    ctx.res.setHeader("Location", "/");
    ctx.res.statusCode = 302;
    ctx.res.end();

    return {
        props: {}
    }
}

export default Stats;
